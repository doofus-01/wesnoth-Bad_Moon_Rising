#textdomain wesnoth-Bad_Moon_Rising

######################################################################################
# These are some WML macros that deal with the (mostly Lua) inventory system.
# It used to be hardcoded to work with side 1 only, but this should no longer be true
######################################################################################

#define BMR_POOL_DUMMY
    ################################################################
    # this is to suppress the warning spam from lua/Status_Test.lua, if there is no inventory
    ################################################################
    [if]
        [variable]
            name=gear_pool.length
            not_equals=1
        [/variable]
        [then]
            [set_variable]
                name=gear_pool.dummy
                value=0
            [/set_variable]
        [/then]
    [/if]
    ################################################################
#enddef

# a little status icon to say that a unit has equipment (of any sort)
#define BMR_INIT_LUA_ICON
    [event]
        name=preload
        first_time_only=no
        [lua]
            code=<<
            local _ = wesnoth.textdomain "wesnoth-Bad_Moon_Rising"
            local old_unit_hard = wesnoth.interface.game_display.unit_race
            function wesnoth.interface.game_display.unit_race()
                local u = wesnoth.interface.get_displayed_unit()
                if not u then return {} end
                local x = old_unit_hard()
		if u.variables.hardened then
                    table.insert(x, { "element", {
                        image = "misc/small-anvil.png",
                        tooltip = _"This unit is tougher than usual."
                    } })
                end                    
                return x
            end
            local old_unit_status = wesnoth.interface.game_display.unit_status
            function wesnoth.interface.game_display.unit_status()
                local u = wesnoth.interface.get_displayed_unit()
                if not u then return {} end
                local s = old_unit_status()
		if u.variables.gear then
                    table.insert(s, { "element", {
                        image = "misc/pack.png",
                        tooltip = _"This unit has equipment."
                    } })
                end
                return s
            end
        >>
        [/lua]
        [set_variable]
            name=bmr_gear_lua_tooltip
            value=fired
        [/set_variable]
    [/event]
#enddef

#define BMR_INIT_LUA_PRESTART

    [lua]
        code = <<
        wesnoth.dofile("~add-ons/Bad_Moon_Rising/lua/main.lua")
        wesnoth.dofile("~add-ons/Archaic_Resources/lua/main.lua")
>>
    [/lua]

    ##########################################
    # units recruited in BfW 1.13.8 seem to no longer have [variables], causing inventory to crash.  This is a hack/fix, not sure if it catches everything...
    [event]
        name=recruit
        first_time_only=no
        #	[filter]
        #	    [filter_side]
        #		controller=human
        #	    [/filter_side]
        #	[/filter]
        [store_unit]
            [filter]
                id=$unit.id
            [/filter]
            variable=init_on_call
            kill=no
        [/store_unit]
        [set_variable]
            name=init_on_call.variables.dummy
            value=yes
        [/set_variable]
        [set_variable]
            name=init_on_call.status.dummy
            value=yes
        [/set_variable]
        [set_variable]
            name=init_on_call.variables.weight
            value=0
        [/set_variable]
        [unstore_unit]
            variable=init_on_call
            find_vacant=no
        [/unstore_unit]
        {CLEAR_VARIABLE init_on_call}
    [/event]
    ##########################################

    [event]
        name=prestart
        {BMR_POOL_DUMMY}
        # to make sure each unit gets a status & variables tag, to fix a change made in BfW 1.13.8
        [store_unit]
            [filter]
                [not]
                    [filter_wml]
                        [status]
                            dummy=yes
                        [/status]
                    [/filter_wml]
                [/not]
            [/filter]
            variable=init_stat
            kill=no
        [/store_unit]
        {FOREACH init_stat iis}
            [set_variable]
                name=init_stat[$iis].status.dummy
                value=yes
            [/set_variable]
            [set_variable]
                name=init_stat[$iis].variables.dummy
                value=yes
            [/set_variable]
            [set_variable]
                name=init_stat[$iis].variables.weight
                value=0
            [/set_variable]
            [unstore_unit]
                variable=init_stat[$iis]
                find_vacant=no
            [/unstore_unit]
        {NEXT iis}
        {CLEAR_VARIABLE init_stat}
        [if]
            [have_unit]
                # only side 1 is on worldmap, so side=1 is OK here, but not for status menu
                side=1
                [filter_side]
                    controller=human
                [/filter_side]
            [/have_unit]
            [then]
                [store_unit]
                    [filter]
                        side=1
                        [not]
                            [filter_wml]
                                [variables]
                                    on_call=yes
                                [/variables]
                            [/filter_wml]
                        [/not]
                    [/filter]
                    variable=init_on_call
                    kill=no
                [/store_unit]
                {FOREACH init_on_call iioc}
                    [set_variable]
                        name=init_on_call[$iioc].variables.on_call
                        value=no
                    [/set_variable]
                    [unstore_unit]
                        variable=init_on_call[$iioc]
                        find_vacant=no
                    [/unstore_unit]
                {NEXT iioc}
                {CLEAR_VARIABLE init_on_call}
            [/then]
        [/if]
        [set_menu_item]
            description = _ "Unit Status"
            id = "inventory_item"
            [show_if]
                [have_unit]
                    x,y=$x1,$y1
                    side=$side_number
                [/have_unit]
                [not] # this is to prevent it from showing up on World Map, it's a hack
                    [have_location]
                        x,y=100,75
                        terrain=Gs^Fp
                    [/have_location]
                [/not]
            [/show_if]
            [command]
                [lua]
                    code= <<
                                local test_dialog2 = Status_test.new()
                        >>
                [/lua]
            [/command]
        [/set_menu_item]
        [if]
            [variable]
                name=total_on_call
                greater_than=0
            [/variable]
            [else]
                [set_variable]
                    name=total_on_call
                    value=0
                [/set_variable]
            [/else]
        [/if]
        [if]
            [variable]
                name=known_items.length
                less_than=1
            [/variable]
            [then]
                [set_variable]
                    name=known_items[0].s
                    value="dummy"
                [/set_variable]
                [set_variable]
                    name=known_items[1].s
                    value="dummy"
                [/set_variable]
                [set_variable]
                    name=known_items[2].s
                    value="dummy"
                [/set_variable]
                [set_variable]
                    name=known_items[3].s
                    value="dummy"
                [/set_variable]
                [set_variable]
                    name=known_items[4].s
                    value="dummy"
                [/set_variable]
                [set_variable]
                    name=known_items[5].s
                    value="dummy"
                [/set_variable]
            [/then]
        [/if]
    [/event]

#enddef

#define BMR_INIT_WML_MOVETO

    [event]
        name=moveto
        first_time_only=no
        [filter]
            #           side=1
            #            [filter_side]
            #                controller=human
            #            [/filter_side]
            [filter_location]
                find_in=gear_map_items
            [/filter_location]
        [/filter]
        {FOREACH gear_map_items mi}
            [if]
                [variable]
                    name=gear_map_items[$mi].x
                    equals=$x1
                [/variable]
                [variable]
                    name=gear_map_items[$mi].y
                    equals=$y1
                [/variable]
                [then]
                    [apply_gear]
                        id = $unit.id
                        gear_id = $gear_map_items[$mi].id
                    [/apply_gear]
                    # might need to re-think this
                    [set_variable]
                        name=mi
                        value=$gear_map_items.length
                    [/set_variable]
                    #                    [floating_text]
                    #                        x,y=$x1,$y1
                    #                        text="<span color='#99aaaa'>" + _ "Takes item..." + "</span>"
                    #                    [/floating_text]
                [/then]
            [/if]
        {NEXT mi}
    [/event]
    # otherwise, these things carry over between maps, and you get random, invisible items being picked up.
    [event]
        name=victory
        {CLEAR_VARIABLE gear_map_items}
    [/event]

#enddef

#define BMR_INIT_WML_DIE

    [event]
        name = die
        first_time_only = no
        [filter]
            [filter_wml]
                [variables]
                    [gear]
                    [/gear]
                [/variables]
            [/filter_wml]
        [/filter]
        {FOREACH unit.variables.gear gi}
            [gear_item]
                x,y=$x1,$y1
                gear_id = $unit.variables.gear[$gi].id
            [/gear_item]
        {NEXT gi}
    [/event]

#enddef

#define BMR_INIT_WML_ADVANCE
    # remove and reapply gear, so that it gets dropped if new unit type can't use an equipped item
    [event]
        name = post advance
        first_time_only = no
        [filter]
            [filter_wml]
                [variables]
                    [gear]
                    [/gear]
                [/variables]
            [/filter_wml]
        [/filter]
        {VARIABLE gi 0}
        [while]
            [variable]
                name=gi
                less_than=$unit.variables.gear.length
            [/variable]
            [do]
                [set_variable]
                    name=gear_id_TEMP
                    value = $unit.variables.gear[$gi].id
                [/set_variable]
                [remove_gear]
                    id=$unit.id
                    gear_id = $gear_id_TEMP
                [/remove_gear]
                [apply_gear]
                    id=$unit.id
                    gear_id = $gear_id_TEMP
                [/apply_gear]
                {CLEAR_VARIABLE gear_id_TEMP}
                [set_variable]
                    name=gi
                    add=1
                [/set_variable]
            [/do]
        [/while]
        {CLEAR_VARIABLE gi}
    [/event]

#enddef

#define BMR_INIT_WML_POOL_SWAP
    # problem with this plan is that anything added to invnetory during start, prestart, etc. will disappear

    [event]
        name=side turn end
        first_time_only=no
        [filter_condition]
            [have_unit]
                side=$side_number
                [filter_side]
                    controller=human
                [/filter_side]
            [/have_unit]
            [variable]
                name=gear_pool.length
                equals=1
            [/variable]
        [/filter_condition]
        [set_variables]
            name=gear_pool_$side_number|
            mode=replace
            to_variable=gear_pool
        [/set_variables]
        {CLEAR_VARIABLE gear_pool}
    [/event]

    [event]
        name=side turn
        first_time_only=no
        [filter_condition]
            [have_unit]
                side=$side_number
                [filter_side]
                    controller=human
                [/filter_side]
            [/have_unit]
            [variable]
                name=gear_pool_$side_number|.length
                equals=1
            [/variable]
        [/filter_condition]
        [set_variables]
            name=gear_pool
            mode=replace
            to_variable=gear_pool_$side_number|
        [/set_variables]
        {CLEAR_VARIABLE gear_pool_$side_number|}
    [/event]

    [event]
        name=side turn
        first_time_only=no
        {BMR_POOL_DUMMY}
    [/event]

    [event]
        name=victory
        # WTF was this for?
        #    [set_variable]
        #	name=side_number_
        #	value=1
        #    [/set_variable]
        [filter_condition]
            [have_unit]
                side=$side_number # does this variable exist now?
                [filter_side]
                    controller=human
                [/filter_side]
            [/have_unit]
            [variable]
                name=gear_pool.length
                equals=1
            [/variable]
            # so the inventory doesn't get wiped out by cut-scenes
            [variable]
                name=turn_number
                greater_than=1
            [/variable]
        [/filter_condition]
        [set_variables]
            name=gear_pool_$side_number|
            mode=replace
            to_variable=gear_pool
        [/set_variables]
        {CLEAR_VARIABLE gear_pool}
    [/event]

#enddef

#define BMR_INIT_RANDOM_GEAR_INTERNAL N UNIT_TYPE GEAR_ID CHANCE
#arg GEAR2_ID
{GEAR_ID}#endarg

    [event]
# not sure if this event is needed
        name=fooby
#        name=start
        id=ai_side_gets_gear_at_start_{N}
        [store_unit]
            [filter]
                type={UNIT_TYPE}
                [filter_side]
                    controller=ai
                [/filter_side]
            [/filter]
            kill=no
            variable=unit_add_gear_TEMP
        [/store_unit]
        [for]
            array=unit_add_gear_TEMP
            variable=uag_i
            [do]
                [set_variable]
                    name=chance_gear
                    rand=1..{CHANCE}
                [/set_variable]
                [switch]
                    variable=chance_gear
                    [case]
                        value=1
                        [apply_gear]
                            id=$unit_add_gear_TEMP[$uag_i].id
                            gear_id={GEAR_ID}
                        [/apply_gear]
                    [/case]
                    [case]
                        value=2
                        [apply_gear]
                            id=$unit_add_gear_TEMP[$uag_i].id
                            gear_id={GEAR2_ID}
                        [/apply_gear]
                    [/case]
                [/switch]
            [/do]
        [/for]
        {CLEAR_VARIABLE unit_add_gear_TEMP}
        {CLEAR_VARIABLE chance_gear}
    [/event]

    [event]
        # name=recruit
        name=unit placed
        id=ai_side_gets_gear_{N}
        first_time_only=no
        [filter]
            type={UNIT_TYPE}
            [filter_side]
                controller=ai
            [/filter_side]
        [/filter]

        [set_variable]
            name=chance_gear
            rand=1..{CHANCE}
        [/set_variable]
        [switch]
            variable=chance_gear
            [case]
                value=1
                [apply_gear]
                    id=$unit.id
                    gear_id={GEAR_ID}
                [/apply_gear]
            [/case]
            [case]
                 value=2
                 [apply_gear]
                    id=$unit.id
                    gear_id={GEAR2_ID}
                 [/apply_gear]
            [/case]
        [/switch]
        {CLEAR_VARIABLE unit_add_gear_TEMP}
        {CLEAR_VARIABLE chance_gear}
    [/event]
#enddef

#define BMR_INIT_RANDOM_GEAR
    # random gear given to the AI enemy units, throughout the campaign - might want to make this Lua instead?
    # undead
    {BMR_INIT_RANDOM_GEAR_INTERNAL U1 (Skeleton,Skeleton Archer,Revenant,Bone Shooter, Banebow, Draug) (rusty_armor) 11}
    {BMR_INIT_RANDOM_GEAR_INTERNAL U2 (Banebow, Draug) (bone_helmet) 9}
    {BMR_INIT_RANDOM_GEAR_INTERNAL U3 (Skeleton, Revenant, Walking Corpse, Soulless) (rusty_helmet) 11}
    {BMR_INIT_RANDOM_GEAR_INTERNAL U4 (Skeleton, Skeleton Archer, Revenant, Bone Shooter, Walking Corpse, Soulless) (rotten_cloak) 6}
    {BMR_INIT_RANDOM_GEAR_INTERNAL U5 (Skeleton, Revenant, Draug) (rusty_axe) 12}
    {BMR_INIT_RANDOM_GEAR_INTERNAL U6 (Skeleton, Revenant, Draug) (rusty_targ) 15}
    # despair
    {BMR_INIT_RANDOM_GEAR_INTERNAL D1 (Phantom Cloak, Phantom Rider) (black_cowl) 12}
    {BMR_INIT_RANDOM_GEAR_INTERNAL D2 (Phantom Shadow, Phantom Master, Phantom Horseman, Phantom Slayer) (black_cowl) 11 GEAR2_ID=sorrow_veil}
    {BMR_INIT_RANDOM_GEAR_INTERNAL D3 (Phantom Cloak, Phantom Shadow, Phantom Master) (black_cloak) 15}
    {BMR_INIT_RANDOM_GEAR_INTERNAL D4 (Phantom Cloak, Phantom Shadow, Phantom Master, Phantom Widow, Phantom Midnight, Phantom White, Phantom Banshee, Phantom Rider, Phantom Horseman, Phantom Slayer) (black_tunic) 15}
    {BMR_INIT_RANDOM_GEAR_INTERNAL D5 (Phantom Cloak, Phantom Shadow, Phantom Widow, Phantom Midnight, Phantom White) (dark_ring) 24}
    {BMR_INIT_RANDOM_GEAR_INTERNAL D6 (Phantom Master, Phantom Banshee, Phantom Slayer) (black_gloves) 13}
    # orcs
    {BMR_INIT_RANDOM_GEAR_INTERNAL O1 (Orcish Slayer, Orcish Drifter, Orcish Wanderer, Orcish Vagrant, Orcish Traveler, Orcish Slinger, Orcish Hunter, Orcish Serf, Orcish Foreman, Orcish Fireline) (orc_cloak) 12 GEAR2_ID=fur_cloak}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O2 (Orcish Drifter, Orcish Wanderer, Orcish Vagrant, Orcish Traveler) (shaman_tunic) 9}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O3 (Orcish Drifter, Orcish Wanderer, Orcish Vagrant, Orcish Traveler) (obsidian_bracelet) 14}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O4 (Orcish Serf, Orcish Foreman, Orcish Fireline) (obsidian_axe) 9}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O5 (Orcish Assassin, Orcish Slayer, Orcish Grunt, Orcish Serf, Orcish Slinger, Orcish Archer) (hide_buckler) 8}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O6 (Orcish Warrior, Orcish Foreman, Orcish Raider, Orcish Hunter, Orcish Crossbowman) (bronze_buckler) 10}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O7 (Orcish Foreman, Orcish Raider, Orcish Fireline, Orcish Hunter, Orcish Crossbowman) (kidney_belt) 16 GEAR2_ID=fang_charm}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O8 (Orcish Archer) (poison_arrows) 23}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O8b (Orcish Crossbowman, Orcish Slurbow) (poison_arrows) 13}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O9 (Orcish Grunt, Orcish Serf, Orcish Slinger, Rat Rider, Orcish Archer, Orcish Rider) (leather_armor) 11}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O10 (Orcish Foreman, Orcish Warrior, Orcish Hunter, Rat Lancer, Orcish Crossbowman, Orcish Slurbow, Orcish Cavalry, Orcish Destrier) (scale_armor) 11}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O11 (Orcish Foreman, Orcish Hunter, Rat Lancer, Orcish Crossbowman, Orcish Slurbow, Orcish Cavalry, Orcish Destrier) (leather_vambrace) 14}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O12 (Archaic_Goblin, Frost Goblin, Rat Rider, Rat Lancer, Rat Dragoon, Orcish SnowWalker, Orcish IceStalker) (obsidian_spear) 8}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O13 (Goblin Spearman, Archaic_Goblin, Frost Goblin, Rat Rider, Rat Lancer, Rat Dragoon, Wolf Rider, Goblin Knight, Goblin Pillager, Direwolf Rider) (padded_coat) 8}
    {BMR_INIT_RANDOM_GEAR_INTERNAL O14 (Orcish Grunt, Orcish Serf, Orcish Foreman, Orcish Warrior, Orcish Hunter, Orcish Crossbowman, Orcish Slurbow, Orcish Warlord) (snow_boots) 11}
    # primeval
    {BMR_INIT_RANDOM_GEAR_INTERNAL P1 (Primevalist Follower, Primevalist Monk, Primevalist Celebrant, Primevalist Prior) (fur_cloak) 6}
    {BMR_INIT_RANDOM_GEAR_INTERNAL P2 (Primevalist Follower, Primevalist Monk, Primevalist Celebrant, Primevalist Prior) (steel_ring) 10 GEAR2_ID=stone_ring}
    {BMR_INIT_RANDOM_GEAR_INTERNAL P3 (Primevalist Fighter, Primevalist Follower, Primevalist Monk, Primevalist Celebrant, Primevalist Prior) (blue_tunic) 10}
    {BMR_INIT_RANDOM_GEAR_INTERNAL P4 (Primevalist Fighter, Primevalist Fanatic) (leather_vambrace) 16 GEAR2_ID=wooden_vambrace}
    {BMR_INIT_RANDOM_GEAR_INTERNAL P5 (Primevalist Fighter, Primevalist Fanatic) (light_helmet) 8}
    {BMR_INIT_RANDOM_GEAR_INTERNAL P6 (Primevalist Leader, Primevalist Shield, Primevalist Shield_High) (steel_helmet) 8}
    {BMR_INIT_RANDOM_GEAR_INTERNAL P7 (Primevalist Leader, Primevalist Shield, Primevalist Shield_High) (chain_armor) 12 GEAR2_ID=scale_armor}
    {BMR_INIT_RANDOM_GEAR_INTERNAL P8 (Primevalist Leader, Primevalist Shield, Primevalist Shield_High) (kidney_belt) 18}
    {BMR_INIT_RANDOM_GEAR_INTERNAL P9 (Primevalist Shield, Primevalist Shield_High) (kite_shield) 9}
    {BMR_INIT_RANDOM_GEAR_INTERNAL P10 (Primevalist Leader, Primevalist Shield, Primevalist Shield_High) (iron_vambrace) 10}
    {BMR_INIT_RANDOM_GEAR_INTERNAL P11 (Primevalist Shield, Primevalist Shield_High, Primevalist Fanatic, Primevalist Leader) (officer_boots) 7}
    {BMR_INIT_RANDOM_GEAR_INTERNAL P12 (Primevalist Fanatic, Primevalist Leader) (iron_buckler) 5}
    # royalists
    {BMR_INIT_RANDOM_GEAR_INTERNAL R1 (Spearman, Pikeman, Halberdier, Swordsman, Royal Guard) (steel_helmet) 6}
    {BMR_INIT_RANDOM_GEAR_INTERNAL R2 (Pikeman, Swordsman, Northern Soldier, Dragoon) (scale_armor) 5}
    {BMR_INIT_RANDOM_GEAR_INTERNAL R3 (Pikeman, Halberdier) (steel_spear) 7}
    {BMR_INIT_RANDOM_GEAR_INTERNAL R4 (Swordsman, Royal Guard) (steel_blade) 7}
    {BMR_INIT_RANDOM_GEAR_INTERNAL R5 (Halberdier, Royal Guard, Northern Elite, Cavalier) (chain_armor) 5}
    {BMR_INIT_RANDOM_GEAR_INTERNAL R6 (Northern Fighter, Spearman, Cavalryman) (leather_armor) 6}
    {BMR_INIT_RANDOM_GEAR_INTERNAL R7 (Northern Fighter, Northern Soldier, Northern Elite) (wooden_shield) 5}
    {BMR_INIT_RANDOM_GEAR_INTERNAL R8 (Northern Fighter, Spearman, Cavalryman, Pikeman, Halberdier, Swordsman, Royal Guard, Northern Soldier, Northern Elite, Dragoon, Cavalier) (leather_gloves) 8}
    {BMR_INIT_RANDOM_GEAR_INTERNAL R9 (Cavalryman, Pikeman, Halberdier, Swordsman, Royal Guard, Northern Soldier, Northern Elite, Dragoon, Cavalier) (leather_vambrace) 10}
    {BMR_INIT_RANDOM_GEAR_INTERNAL R10 (Cavalryman, Pikeman, Halberdier, Swordsman, Royal Guard, Northern Soldier, Northern Elite, Dragoon, Cavalier) (officer_boots) 12}
    #elves
    {BMR_INIT_RANDOM_GEAR_INTERNAL E1 (Elvish Fighter, Elvish Archer, Elvish Ranger, Elvish Hero, Elvish Captain, Elvish Champion, Elvish Marshal, Elvish Marksman, Elvish Sharpshooter, Elvish Avenger) (elf_cloak) 6}
    {BMR_INIT_RANDOM_GEAR_INTERNAL E2 (Elvish Fighter, Elvish Archer, Elvish Ranger, Elvish Hero, Elvish Captain, Elvish Champion, Elvish Marshal, Elvish Marksman, Elvish Sharpshooter, Elvish Avenger) (elven_tunic) 6}

#enddef

# this isn't really inventory, but it is part of the same balancing act
#define BMR_ENEMY_BALANCE_PLAYER_INTERNAL FILTER VAR

    [set_variable]
        name=player_resistance_TMP.blade
        value=0
    [/set_variable]
    [set_variable]
        name=player_resistance_TMP.impact
        value=0
    [/set_variable]
    [set_variable]
        name=player_resistance_TMP.pierce
        value=0
    [/set_variable]
    [set_variable]
        name=player_resistance_TMP.arcane
        value=0
    [/set_variable]
    [set_variable]
        name=player_resistance_TMP.cold
        value=0
    [/set_variable]
    [set_variable]
        name=player_resistance_TMP.fire
        value=0
    [/set_variable]
    [store_unit]
        [filter]
            {FILTER}
        [/filter]
        kill=no
        variable={VAR}
    [/store_unit]
    [foreach]
        array={VAR}
        [do]
            [set_variable]
                name=player_resistance_TMP.blade
                add=$this_item.resistance.blade
            [/set_variable]
            [set_variable]
                name=player_resistance_TMP.impact
                add=$this_item.resistance.impact
            [/set_variable]
            [set_variable]
                name=player_resistance_TMP.pierce
                add=$this_item.resistance.pierce
            [/set_variable]
            [set_variable]
                name=player_resistance_TMP.arcane
                add=$this_item.resistance.arcane
            [/set_variable]
            [set_variable]
                name=player_resistance_TMP.cold
                add=$this_item.resistance.cold
            [/set_variable]
            [set_variable]
                name=player_resistance_TMP.fire
                add=$this_item.resistance.fire
            [/set_variable]
        [/do]
    [/foreach]
    [set_variable]
        name=player_resistance.blade
        formula=" min( $player_resistance.blade|  , floor( $player_resistance_TMP.blade| / ${VAR}.length| ) )"
    [/set_variable]
    [set_variable]
        name=player_resistance.impact
        formula=" min( $player_resistance.impact|  , floor( $player_resistance_TMP.impact| / ${VAR}.length| ) )"
    [/set_variable]
    [set_variable]
        name=player_resistance.pierce
        formula=" min( $player_resistance.pierce|  , floor( $player_resistance_TMP.pierce| / ${VAR}.length| ) )"
    [/set_variable]
    [set_variable]
        name=player_resistance.arcane
        formula=" min( $player_resistance.arcane|  , floor( $player_resistance_TMP.arcane| / ${VAR}.length| ) )"
    [/set_variable]
    [set_variable]
        name=player_resistance.cold
        formula=" min( $player_resistance.cold|  , floor( $player_resistance_TMP.cold| / ${VAR}.length| ) )"
    [/set_variable]
    [set_variable]
        name=player_resistance.fire
        formula=" min( $player_resistance.fire|  , floor( $player_resistance_TMP.fire| / ${VAR}.length| ) )"
    [/set_variable]
    {CLEAR_VARIABLE {VAR}}
    {CLEAR_VARIABLE player_resistance_TMP}
#enddef

#define BMR_ENEMY_BALANCE

[event]
    name=prestart
    [set_variable]
        name=player_resistance.blade
        value=100
    [/set_variable]
    [set_variable]
        name=player_resistance.impact
        value=100
    [/set_variable]
    [set_variable]
        name=player_resistance.pierce
        value=100
    [/set_variable]
    [set_variable]
        name=player_resistance.arcane
        value=100
    [/set_variable]
    [set_variable]
        name=player_resistance.cold
        value=100
    [/set_variable]
    [set_variable]
        name=player_resistance.fire
        value=100
    [/set_variable]
# use the stronger average of either the lvl3-lvl5 or the leader+loyals (but no dogs)
# still possible to game, 
{BMR_ENEMY_BALANCE_PLAYER_INTERNAL (
        # could just be side 1 in most cases
        # could there be more than one human-controlled side?
            [filter_side]
                controller=human
            [/filter_side]
            level=3,4,5
            [and] # count everyone, map and recall
                x,y=1-99,1-99
                [or]
                x,y=recall,recall
                [/or]
            [/and]
) "l3_l5_filter"}
{BMR_ENEMY_BALANCE_PLAYER_INTERNAL (
            [filter_side]
                controller=human
            [/filter_side]
            level = 2,3,4,5
            [and]
                upkeep = loyal
                [or]
                    canrecruit=yes
                [/or]
            [/and]
            [and] # count everyone, map and recall
                x,y=1-99,1-99
                [or]
                x,y=recall,recall
                [/or]
            [/and]
            [not]
                race=ukiandog
            [/not]
) "loyals_filter"}
[/event]

[event]
    name=unit placed
    id=enemy_ai_buff
    first_time_only=no
    [filter]
        [filter_side]
            controller=ai
            [has_enemy]
                controller=human
            [/has_enemy]
        [/filter_side]
        [not]
            [filter_wml]
                [variables]
                    hardened=1
                [/variables]
            [/filter_wml]
        [/not]
    [/filter]
    # ###############################################################################
    # The purpose here isn't to make the perfect counter, it is to just raise the baseline
    # 
    # One method considered: increase the resistance by X% where X = A*(player_resistance - ai_resistance)
    # so that for A = 0.5, enemy w/ 10% vulnerability against a player with 60% resistance
    # would get 110 + 0.5*(40 - 110) = 75
    # and enemy w/ 30% resistance against a player with 60% resistance
    # would get 70 + 0.5*(40 - 70) = 55
    # but this would, at best, cause very long stalemates
    #
    # second method: increase enemy attacks by -1.6*(player_resistance - ai_resistance)
    # so that 10% resistance enemy w/ a 12dmg strike against 60% player resistance would be 
    # 12*(1 - 1.6*(.4 - .9)) = 20.4; 20.4 * .4 = 8.16 (8 instead of 5) 
    #
    # ultimately, blend the two
    # resistance -> add A%resistance*(average(player_resistance))
    # HP -> add B%HP*(player_resistance-ai_resistance)
    # attack -> add (C*(player_resistance))%
    
    # resistance parameter
    [set_variable] 
        name = aaa
        {QUANTITY value (0.2) (0.4) (0.6)}
    [/set_variable]

    # HP parameter
    [set_variable] 
        name = bbb
        {QUANTITY value (0.2) (0.5) (0.8)}
    [/set_variable]

    # damage parameter
    [set_variable] 
        name = ccc
        {QUANTITY value (0.3) (0.5) (0.7)}
    [/set_variable]

    [set_variable] 
        name = inc_resist.base
        value = 0
    [/set_variable]
    [set_variables]
        name=arr
        mode=replace
        [value]
            foo=blade
        [/value]
        [value]
            foo=impact
        [/value]
        [value]
            foo=pierce
        [/value]
        [value]
            foo=arcane
        [/value]
        [value]
            foo=cold
        [/value]
        [value]
            foo=fire
        [/value]
    [/set_variables]
    [foreach]
        array=arr
        [do]
    [set_variable]
        name=d_type
        value=$arr[$i].foo
    [/set_variable]
    # [wml_message]
    #     message="unit.resistance.d_type = $unit.resistance.$d_type from $d_type of $unit.id"
    #     logger=err
    # [/wml_message]
    [set_variable] 
        name = inc_resist.base
        add = $player_resistance.$d_type
    [/set_variable]
    [set_variable] 
        name = resist_delta
        value = $unit.resistance.$d_type
    [/set_variable]
    [set_variable] 
        name = resist_delta
        add = -$player_resistance.$d_type
    [/set_variable]
    [set_variable] 
        name = resist_delta
        max = "0, $resist_delta|"
    [/set_variable]
    [set_variable] 
        name = inc_damage
        value= $resist_delta
    [/set_variable]
    # scale this for difficulty
    [set_variable] 
        name = inc_damage
        multiply= $ccc
    [/set_variable]
    #
    [modify_unit]
        [filter]
            id=$unit.id
            [has_attack]
                type=$d_type
            [/has_attack]
        [/filter]
        [object]
        silent=yes
        buff_id=formula_attack_buff
        [effect]
            apply_to=attack
            type=$d_type
            increase_damage=$inc_damage|%
        [/effect]
        [/object]
    [/modify_unit]
        [/do]
    [/foreach]
    [set_variable] 
        name = inc_resist.base
        divide = 6
    [/set_variable]
    [set_variable] 
        name = inc_resist.base
        round = floor
    [/set_variable]
    [set_variable] 
        name = inc_HP
        formula= "100 - $inc_resist.base"
    [/set_variable]
    # scale this for difficulty
    [set_variable] 
        name = inc_HP
        multiply= $bbb
    [/set_variable]
    #
    [set_variable] 
        name = inc_resist.arcane
        formula = "$aaa| * max( 0 , $unit.resistance.arcane| - $inc_resist.base| )" 
    [/set_variable]
    [set_variable] 
        name = inc_resist.blade
        formula = "$aaa| * max( 0 , $unit.resistance.blade| - $inc_resist.base| )" 
    [/set_variable]
    [set_variable] 
        name = inc_resist.cold
        formula = "$aaa| * max( 0 , $unit.resistance.cold| - $inc_resist.base| )" 
    [/set_variable]
    [set_variable] 
        name = inc_resist.fire
        formula = "$aaa| * max( 0 , $unit.resistance.fire| - $inc_resist.base| )" 
    [/set_variable]
    [set_variable] 
        name = inc_resist.impact
        formula = "$aaa| * max( 0 , $unit.resistance.impact| - $inc_resist.base| )" 
    [/set_variable]
    [set_variable] 
        name = inc_resist.pierce
        formula = "$aaa| * max( 0 , $unit.resistance.pierce| - $inc_resist.base| )" 
    [/set_variable]
    [modify_unit]
        [filter]
            id=$unit.id
        [/filter]
        [object]
        silent=yes
        buff_id=formula_resist_buff
        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                arcane=-$inc_resist.arcane|
                blade=-$inc_resist.blade|
                cold=-$inc_resist.cold|
                fire=-$inc_resist.fire|
                impact=-$inc_resist.impact|
                pierce=-$inc_resist.pierce|
            [/resistance]
        [/effect]
        [effect]
            apply_to=hitpoints
            heal_full=yes
            increase_total=$inc_HP|%
        [/effect]
        [/object]
        [set_variable]
            name=hardened
            value=1
        [/set_variable]
    [/modify_unit]
    # TO DO: use inc_resist.base to scale the 'hardened' unit variable, 
    # so that visual indicators can be adjusted
    {CLEAR_VARIABLE aaa}
    {CLEAR_VARIABLE bbb}
    {CLEAR_VARIABLE ccc}
    {CLEAR_VARIABLE player_strong_units}
    {CLEAR_VARIABLE arr}
    {CLEAR_VARIABLE inc_resist}
    {CLEAR_VARIABLE inc_damage}
    {CLEAR_VARIABLE inc_HP}
[/event]

#enddef

#define BMR_INIT_LUA

    {BMR_INIT_LUA_ICON}
    {BMR_INIT_LUA_RECRUIT_NUMBERS}
    {BMR_INIT_LUA_PRESTART}
    {BMR_INIT_WML_POOL_SWAP}
    {BMR_INIT_WML_MOVETO}
    {BMR_INIT_WML_DIE}
    {BMR_INIT_WML_ADVANCE}
    {BMR_INIT_SIDE_RECRUIT}
    {BMR_INIT_RANDOM_GEAR}
    {BMR_ENEMY_BALANCE}

#enddef

# mostly useful for Part 1
#define BMR_INIT_LUA_LITE

    {BMR_INIT_LUA_ICON}
    # no recruiting in Part 1
    #    {BMR_INIT_LUA_RECRUIT_NUMBERS}
    {BMR_INIT_LUA_PRESTART}
    # No side-swapping in Part 1
    #    {BMR_INIT_WML_POOL_SWAP}
    {BMR_INIT_WML_MOVETO}
    {BMR_INIT_WML_DIE}
    {BMR_INIT_WML_ADVANCE}
    # no recruiting in Part 1
    #    {BMR_INIT_SIDE_RECRUIT}
    # this can cause enemies to be too strong in Part 1.
    #    {BMR_INIT_RANDOM_GEAR}

#enddef
